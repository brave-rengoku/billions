<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Billions: Blue Guardian</title>
<link rel="shortcut icon" href="favicon.png" type="image/x-icon">
<style>
  :root{
    --bg:#071226;
    --card:#071a2b;
    --primary:#0046ff;
    --muted:#9fb0c2;
    --white:#e9f3f8;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,var(--bg), #04111a);}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px;box-sizing:border-box;}
  .card{width:720px;max-width:96vw;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 10px 40px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03);}
  header{display:flex;align-items:center;margin-bottom:20px}
  .title{font-size:30px;font-weight:700;color:#00BFFF;margin-bottom:6px} .subtitle{color:var(--muted)}
  #gameCanvas{
  background:#061521;
  border-radius:8px;
  display:block;
  margin:10px auto;
  touch-action:none;
  width:100%;
  max-width:640px;  /* don't exceed design size */
  height:auto;      /* keep aspect ratio */
}

  .row{display:flex;align-items:center;gap:8px;justify-content:space-between}
  .controls{display:none;gap:8px;align-items:center}
  .btn{background:var(--primary);border:none;color:white;padding:8px 12px;border-radius:8px;font-weight:700;cursor:pointer}
  .small{color:var(--muted);font-size:13px}
  /* mobile arrows */
  /* mobile arrows: scale and center on small screens */
.mobile-arrows{
  display:none;
  margin-top:10px;
  justify-content:center;
  gap:8px;
}
@media (max-width:700px){
  .mobile-arrows{display:flex}
  .arrow{
    width:72px;
    height:72px;
    border-radius:12px;
    font-size:22px;
  }
  .card{padding:12px;}
  .title{font-size:16px;}
  .small{font-size:12px;}
}
  .arrow{
  width:56px;height:56px;border-radius:10px;background:rgba(255,255,255,0.02);
  display:flex;align-items:center;justify-content:center;color:var(--white);font-weight:700;
  touch-action: manipulation;
  -webkit-user-select: none;
  user-select: none;
}

  @media (max-width:700px){ .mobile-arrows{display:flex} }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="application" aria-label="Billions mascot game">
    <header>
      <div>
        <div class="title">Billions: Blue Guardian</div>
        <div class="subtitle">Where Bots Go to Regret Their Life Choices</div>
      </div>
      <div style="margin-left:auto;text-align:right">
        <div class="small">Score: <span id="score">0</span></div>
        <div class="small">High: <span id="high">0</span></div>
      </div>
    </header>

    <canvas id="gameCanvas" width="640" height="640" aria-label="Mascot game canvas"></canvas>

    <div class="row" style="margin-top:10px">
      <div class="controls">
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="resetBtn">Reset</button>
      </div>
      <div class="small" style="width:100%;margin:auto;display:flex;justify-content:space-between"><span></span><span>ðŸ’™ Made in collaboration between Human & AI</span></div>
    </div>

    <div class="mobile-arrows" aria-hidden>
      <div style="display:flex;align-items:center;flex-direction:column;gap:8px;">
        <div class="arrow" id="upBtn">â–²</div>
        <div style="display:flex;gap:8px;justify-content:center">
          <div class="arrow" id="leftBtn">â—€</div>
          <div class="arrow" id="downBtn">â–¼</div>
          <div class="arrow" id="rightBtn">â–¶</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/*
  Billions: Mascot vs Bots
  - Single file game: canvas + JS
  - Grid-based snake. Head is drawn as mascot SVG rendered on canvas (keeps same sprite size)
  - Bots are food. On collision: particle explosion + score + snake grows
  - Tweak variables below to tune difficulty/feel
*/

// Responsive canvas + grid (will adapt to viewport)
let CANVAS_SIZE = 640;     // drawing buffer size (square)
let GRID = 40;             // size of each grid cell in px (will be recalculated)
let COLS = 16;             // columns (will be recalculated)
let ROWS = 16;             // rows (will be recalculated)

// Keep gameplay timing constants
const FPS = 12;                  // base moves per second (speed)
const BOT_SPAWN_INTERVAL = 1600; // ms between spawns
const MAX_BOTS = 6;              // max bots on board
const INITIAL_SNAKE_LEN = 4;

// Compute grid from desired canvas pixel size
function computeGridForSize(size){
  // pick a grid cell count that divides nicely â€” keep 16 columns if possible
  // choose a preferred number of columns (16) but shrink to maintain whole GRID
  const preferredCols = 16;
  const gridPx = Math.floor(size / preferredCols);
  // enforce min/max grid sizes so elements don't vanish
  GRID = Math.max(20, Math.min(48, gridPx));
  COLS = Math.floor(size / GRID);
  ROWS = Math.floor(size / GRID);
  CANVAS_SIZE = Math.min(size, GRID * Math.max(COLS, ROWS));
}


/* -------------- State -------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// Responsive canvas resizing helper
function resizeCanvasToViewport(){
  // choose available width inside card; leave small margin
  const containerPadding = 32; // room for padding / UI
  const maxWidth = Math.min(window.innerWidth - containerPadding, 720);
  // keep square canvas, but don't be wider than 640 unless bigger screens
  const target = Math.round(Math.max(320, Math.min(640, maxWidth)));
  // compute grid & cols based on target drawing size
  computeGridForSize(target);
  // set canvas drawing buffer size (important)
  canvas.width = GRID * COLS;
  canvas.height = GRID * ROWS;
  // also set CSS size so it scales fluidly
  canvas.style.width = Math.min(window.innerWidth - 36, 640) + 'px';
  canvas.style.height = 'auto';
}
// call once now
resizeCanvasToViewport();
// recompute on window resize (debounced)
let _rTO = null;
window.addEventListener('resize', ()=> {
  clearTimeout(_rTO);
  _rTO = setTimeout(()=> {
    const wasRunning = isRunning;
    // pause timers while we resize to keep state safe
    pauseGame();
    resizeCanvasToViewport();
    // re-render correctly sized canvas
    render();
    // restore running state if it was running
    if(wasRunning) startGame();
  }, 120);
});
let gameInterval = null;
let stepTimer = null;
let spawnTimer = null;
let isRunning = false;
let scoreEl = document.getElementById('score');
let highEl = document.getElementById('high');

let highScore = Number(localStorage.getItem('billions_high') || 0);
highEl.textContent = highScore;

let dir = { x: 1, y: 0 };
let nextDir = null;
let snake = [];
let bots = []; // array of {x,y,spawnedAt, kind}
let particles = [];
let score = 0;
let gameOver = false;
let CLICK_AREA = null;


// ----- Points per bot kind & tracking -----
const POINTS_BY_KIND = {
  bot: 100,           // common spam bot
  hacker: 200,        // harder, more valuable
  idThief: 200,       // medium value
  spam: 100,          // spammy but common
  neighbourCat: 1000  // legendary cat = big points
};

// counts per kind (reset in resetGame)
let destroyedCounts = {
  bot: 0,
  hacker: 0,
  idThief: 0,
  spam: 0,
  neighbourCat: 0
};



/* -------------- Mascot sprite: inline SVG rendered to image -------------- */
/* We draw a simple stylized mascot SVG. Replace SVG markup if you have a real mascot SVG. */
const mascotSVG = `
<svg xmlns="http://www.w3.org/2000/svg" width="90" height="90" viewBox="0 0 45 30" fill="none">
  <path d="M29.6607 0C35.558 0 40.3386 4.78067 40.3386 10.6779V11.8811H42.4805C43.6567 11.8811 44.6102 12.8346 44.6102 14.0107C44.6102 15.1869 43.6567 16.1404 42.4805 16.1404H40.3386V20.0001C40.3386 24.4183 36.757 28 32.3387 28H12.2714C7.85323 27.9999 4.27157 24.4183 4.27152 20.0001V16.1404H2.12963C0.953468 16.1404 0 15.1869 0 14.0107C0 12.8346 0.953468 11.8811 2.12963 11.8811H4.27152V10.6779C4.27154 4.78068 9.0522 2.03349e-05 14.9494 0C17.8003 0 20.39 1.1174 22.3051 2.93787C24.2201 1.11738 26.8099 9.83029e-06 29.6607 0Z" fill="#0046FF"></path>
  <path d="M10.916 10.6779C10.916 8.45008 12.7221 6.64404 14.9499 6.64404C17.1778 6.64404 18.9838 8.45008 18.9838 10.6779V18.6658C18.9838 20.1515 17.7794 21.3559 16.2937 21.3559H13.6061C12.1204 21.3559 10.916 20.1515 10.916 18.6658V10.6779Z" fill="black"></path>
  <path d="M16.2937 19.5626V21.356H13.6061V19.5626H16.2937ZM17.1904 18.6659V10.678C17.1904 9.44066 16.1874 8.43747 14.95 8.43742C13.7126 8.43742 12.7094 9.44063 12.7094 10.678V18.6659C12.7094 19.1611 13.1109 19.5626 13.6061 19.5626V21.356L13.5367 21.3551C12.1062 21.3189 10.9531 20.1658 10.9169 18.7353L10.916 18.6659V10.678C10.916 8.45018 12.7222 6.64404 14.95 6.64404L15.054 6.64536C17.2338 6.70056 18.9838 8.48498 18.9838 10.678V18.6659L18.9829 18.7353C18.9467 20.1658 17.7937 21.3189 16.3631 21.3551L16.2937 21.356V19.5626C16.7889 19.5626 17.1904 19.1611 17.1904 18.6659Z" fill="white"></path>
  <path d="M25.6279 10.6779C25.6279 8.45008 27.434 6.64404 29.6618 6.64404C31.8897 6.64404 33.6957 8.45008 33.6957 10.6779V18.6658C33.6957 20.1515 32.4913 21.3559 31.0057 21.3559H28.318C26.8323 21.3559 25.6279 20.1515 25.6279 18.6658V10.6779Z" fill="black"></path>
  <path d="M31.0056 19.5626V21.356H28.318V19.5626H31.0056ZM31.9023 18.6659V10.678C31.9023 9.44066 30.8993 8.43747 29.6619 8.43742C28.4245 8.43742 27.4213 9.44063 27.4213 10.678V18.6659C27.4213 19.1611 27.8228 19.5626 28.318 19.5626V21.356L28.2486 21.3551C26.8181 21.3189 25.6651 20.1658 25.6288 18.7353L25.6279 18.6659V10.678C25.6279 8.45018 27.4341 6.64404 29.6619 6.64404L29.7659 6.64536C31.9457 6.70056 33.6957 8.48498 33.6957 10.678V18.6659L33.6948 18.7353C33.6586 20.1658 32.5056 21.3189 31.075 21.3551L31.0056 21.356V19.5626C31.5008 19.5626 31.9023 19.1611 31.9023 18.6659Z" fill="white"></path>
</svg>
`;
const mascotImg = new Image();
mascotImg.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(mascotSVG);

/* ===== Bot SVGs â€” replace these strings with your found SVGs if you like ===== */
const botSVG          = `<svg id="emoji" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg">
  <g id="color">
    <path fill="#D22F27" d="M34,16.1123v-2.5109c0-1.3807,1.1193-2.5,2.5-2.5l0,0c1.3807,0,2.5,1.1193,2.5,2.5v2.5"/>
    <path fill="#D0CFCE" d="M13.5,41.1014L13.5,41.1014c-1.3807,0-2.5-1.1193-2.5-2.5v-8c0-1.3807,1.1193-2.5,2.5-2.5l0,0 c1.3807,0,2.5,1.1193,2.5,2.5v8C16,39.9821,14.8807,41.1014,13.5,41.1014z"/>
    <path fill="#D0CFCE" d="M58.5,41.1014L58.5,41.1014c1.3807,0,2.5-1.1193,2.5-2.5v-8c0-1.3807-1.1193-2.5-2.5-2.5l0,0 c-1.3807,0-2.5,1.1193-2.5,2.5v8C56,39.9821,57.1193,41.1014,58.5,41.1014z"/>
    <path fill="#D0CFCE" d="M47.4505,56.1123h-22.901c-4.7022,0-8.5495-3.8473-8.5495-8.5495v-22.901 c0-4.7022,3.8473-8.5495,8.5495-8.5495h22.901c4.7022,0,8.5495,3.8473,8.5495,8.5495v22.901 C56,52.2649,52.1527,56.1123,47.4505,56.1123z"/>
    <path fill="#9B9B9A" d="M35.4977,56.1115h13.2865c3.9687,0,7.2158-3.8473,7.2158-8.5495V24.661 c0-4.7022-3.2471-8.5495-7.2158-8.5495h-2.3526"/>
    <ellipse cx="44.8346" cy="29.0027" rx="2.8338" ry="2.8338" fill="#FFFFFF"/>
    <ellipse cx="27.3342" cy="29.0022" rx="2.8338" ry="2.8338" fill="#FFFFFF"/>
    <path fill="#FFFFFF" d="M44.5,47.5005h-17c-2.2,0-4-1.8-4-4l0,0c0-2.2,1.8-4,4-4h17c2.2,0,4,1.8,4,4l0,0 C48.5,45.7005,46.7,47.5005,44.5,47.5005z"/>
  </g>
  <g id="hair"/>
  <g id="skin"/>
  <g id="skin-shadow"/>
  <g id="line">
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2" d="M34,16.0109V13.5c0-1.3807,1.1193-2.5,2.5-2.5l0,0c1.3807,0,2.5,1.1193,2.5,2.5V16"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2" d="M47.4505,56h-22.901C19.8473,56,16,52.1527,16,47.4505v-22.901C16,19.8473,19.8473,16,24.5495,16h22.901 C52.1527,16,56,19.8473,56,24.5495v22.901C56,52.1527,52.1527,56,47.4505,56z"/>
    <ellipse cx="44.8346" cy="29.0022" rx="2.8338" ry="2.8338" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2"/>
    <ellipse cx="27.3342" cy="29.0017" rx="2.8338" ry="2.8338" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2"/>
    <path fill="none" stroke="#000000" stroke-miterlimit="2" stroke-width="2" d="M44.5,47.5h-17c-2.2,0-4-1.8-4-4l0,0 c0-2.2,1.8-4,4-4h17c2.2,0,4,1.8,4,4l0,0C48.5,45.7,46.7,47.5,44.5,47.5z"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2" d="M13.5,41L13.5,41c-1.3807,0-2.5-1.1193-2.5-2.5v-8c0-1.3807,1.1193-2.5,2.5-2.5l0,0c1.3807,0,2.5,1.1193,2.5,2.5v8 C16,39.8807,14.8807,41,13.5,41z"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2" d="M58.5,41L58.5,41c1.3807,0,2.5-1.1193,2.5-2.5v-8c0-1.3807-1.1193-2.5-2.5-2.5l0,0c-1.3807,0-2.5,1.1193-2.5,2.5v8 C56,39.8807,57.1193,41,58.5,41z"/>
    <line x1="28" x2="28" y1="40" y2="47" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2"/>
    <line x1="33" x2="33" y1="40" y2="47" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2"/>
    <line x1="38" x2="38" y1="40" y2="47" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2"/>
    <line x1="43" x2="43" y1="40" y2="47" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="2" stroke-width="2"/>
  </g>
</svg>

`;

const hackerSVG      = `<svg id="emoji" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="color" transform="matrix(1.579 .4213 -.4231 1.572 4.013 -9.525)">
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="#4DFED1" d="m20.79 13.75c4.486-1.907 9.794-2.444 15.54-2.258 6.094-0.08112 11.72 0.4806 16.13 2.738 4.116 1.533 3.637 7.559 3.604 13.56 0.0665 5.123 0.3569 9.4-1.457 13.54-2.018 6.04-5.354 10.53-8.93 14.75-1.267 1.212-2.747 2.396-4.686 3.522-1.539 0.5021-3.132 0.9175-4.989 0.9047l-3.452-0.3979c-2.798-0.9362-4.443-2.413-6.064-3.901-3.49-3.68-6.748-8.312-9.237-16.11-1.045-3.183-1.92-6.823-1.307-14.46-0.035-6.012 0.5461-10.53 4.848-11.88z"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#4DFED1" stroke-linecap="round" d="m32.02 36.1 1.35-10.91"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#4DFED1" stroke-linecap="round" d="m39.85 36.1-1.01-10.98"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#4DFED1" d="m16 36.25c4.697 2.945 9.711 4.327 15.89 0"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#4DFED1" d="m55.88 36.22c-4.697 2.945-9.711 4.327-15.89 0"/>
  </g>
  <g id="line" transform="matrix(1.579 .4213 -.4231 1.572 4.013 -9.525)">
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m32.02 36.1c-2.187 2.411-1.531 2.89-1.409 3.732 1.997-0.3199 3.52 1.314 5.322 1.664"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m39.85 36.1c2.187 2.411 1.531 2.89 1.409 3.732-1.997-0.3199-3.52 1.314-5.322 1.664"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8556 6.288)" stroke-width="0.4295" d="m36.07 60.5 2.482-0.237 0.1543-3.484s0.0814-1.791 0.4668-3.713c1.055-5.259 1.291-4.883-3.076-4.883-0.0091 0-0.01817 3e-6 -0.02724 1e-5z" class="UnoptimicedTransforms"/>
    <path transform="matrix(-.5908 .1583 .159 .5934 41.8 -5.143)" stroke-width="0.4295" d="m36.07 60.5 2.482-0.237 0.1543-3.484s0.0814-1.791 0.4668-3.713c1.055-5.259 1.291-4.883-3.076-4.883-0.0091 0-0.01817 3e-6 -0.02724 1e-5z" class="UnoptimicedTransforms"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" stroke-width="0.4295" d="m30.78 46.53c-0.6605-0.9987 0.4962-1.258 5.604-1.258 4.844 0 5.324 0.06719 5.189 0.7266-0.1301 0.6342-0.8072 0.7414-5.329 0.8432-3.214 0.0724-5.288-0.04579-5.463-0.3114z"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" d="m50.91 23.98c0.3774 0.2199 0.4675-0.651 0.4675-1.902 0-1.6-0.0152-1.714-3.209-2.043-2.207-0.1426-3.003 0.02065-5.336 1.094-1.508 0.6936-3.307 1.813-3.999 2.488-1.065 1.039-1.181 1.36-0.7576 2.099 0.6767 1.182 2.054 1.097 3.736-0.2283 3.047-2.401 6.522-3.144 9.097-1.506z"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" d="m21.29 23.98c-0.3774 0.2199-0.4675-0.651-0.4675-1.902 0-1.6 0.0152-1.714 3.209-2.043 2.207-0.1426 3.003 0.02065 5.336 1.094 1.508 0.6936 3.307 1.813 3.999 2.488 1.065 1.039 1.181 1.36 0.7576 2.099-0.6767 1.182-2.054 1.097-3.736-0.2283-3.047-2.401-6.522-3.144-9.097-1.506z"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" stroke-width="0.4295" d="m24 31.11c-2.437-0.6575-1.589-2.353 1.261-2.521 2.377-0.1407 5.607 0.4718 6.239 1.183 0.4804 0.5409 0.4359 0.7423-0.2707 1.225-0.9578 0.6545-4.989 0.7177-7.229 0.1133zm17.43-0.1133c-1.239-0.8469-0.207-1.795 2.378-2.185 3.848-0.5801 6.295-0.05888 6.295 1.341 0 1.265-7.053 1.951-8.673 0.844z"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="m22.57 38.8 2.911 5.042h7.669l1.512-2.44"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="m49.27 38.78-2.911 5.042h-7.669l-1.512-2.427"/>
    <path transform="matrix(.5908 -.1583 .159 .5934 -.8562 6.288)" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="m20.79 13.75c4.486-1.907 9.794-2.444 15.54-2.258 6.094-0.08112 11.72 0.4806 16.13 2.738 4.116 1.533 3.637 7.559 3.604 13.56 0.0665 5.123 0.3569 9.4-1.457 13.54-2.018 6.04-5.354 10.53-8.93 14.75-1.267 1.212-2.747 2.396-4.686 3.522-1.539 0.5021-3.132 0.9175-4.989 0.9047l-3.452-0.3979c-2.798-0.9362-4.443-2.413-6.064-3.901-3.49-3.68-6.748-8.312-9.237-16.11-1.045-3.183-1.92-6.823-1.307-14.46-0.035-6.012 0.5461-10.53 4.848-11.88z"/>
    <path transform="matrix(.5909 -.1584 .159 .5935 -.8564 6.289)" fill="none" stroke="#000" stroke-linecap="round" stroke-width="0.9998" d="m32.02 36.09 1.35-10.91"/>
    <path transform="matrix(.5909 -.1584 .159 .5935 -.8564 6.289)" fill="none" stroke="#000" stroke-linecap="round" stroke-width="0.9998" d="m39.84 36.09-1.01-10.98"/>
  </g>
</svg>

`;

const idThiefSVG     = `<svg id="emoji" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg">
  <g id="color">
    <path fill="#4DFED1" stroke="#4DFED1" stroke-linecap="round" stroke-linejoin="round" stroke-width="8" d="M39.462,55.4981c-2.5312,0-5.0967-.6445-7.4521-2.002-6.5674-3.7852-11.1914-9.5928-13.7422-17.2598-2.6152-7.8604,1.6377-16.3535,9.498-18.9688,7.8652-2.6123,16.3535,1.6377,18.9688,9.498.1318.3975.2412.6377.3066.7656,7.0908,4.168,9.5391,13.3018,5.4229,20.4414-2.7793,4.8223-7.8184,7.5254-13.002,7.5254ZM47.1065,27.6485h0Z"/>
  </g>
  <g id="line">
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M32.501,31.501c1.3477,4.0511,3.5,6.9826,7,9"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M31.5317,40.1894c-1.606-1.9898-2.8563-4.3498-3.7748-7.1103-.8721-2.6201.5459-5.4512,3.166-6.3223,1.9636-.6548,4.0481-.0209,5.3351,1.4428"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M38.0129,31.8399c.9443,1.9539,2.1985,3.2991,3.9852,4.3291,2.3926,1.3789,3.2139,4.4365,1.835,6.8291-.9258,1.6055-2.6074,2.5039-4.3369,2.5039-.8467,0-1.7051-.2158-2.4922-.6689-.9515-.5485-1.838-1.1559-2.661-1.8243"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M23.0127,34.6582c-1.7441-5.2412,1.0908-10.9023,6.3311-12.6455"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M39.4913,50.503c-1.6943,0-3.4111-.4316-4.9844-1.3379-4.474-2.5797-7.7842-6.1621-10.0431-10.8893"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M33.2879,21.529c3.886.3072,6.6155,3.2376,8.7015,6.8148,1.5538,2.6645,3.4549,2.9065,5.366,5.9631"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M48.6002,28.5828c3.5583,2.737,5.6179,6.8591,5.8426,11.1488M20.1747,22.9516c1.7844-2.5769,4.3882-4.6184,7.591-5.684,7.4598-2.4776,15.48,1.2177,18.5183,8.3116M31.1174,52.9619c-6.0953-3.7882-10.4161-9.4106-12.8497-16.7255-1.0961-3.2943-.9857-6.6998.091-9.7371"/>
  </g>
</svg>

`;

const catSVG         = `<svg id="emoji" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg">
  <g id="color">
    <path fill="#92d3f5" d="m17.1347,58.8989s-2-13.5,10-13.5c3.1918,2.1279,5.9264,3.5984,9,3.5922h-.1247c3.1016-.1525,5.4081-2.1643,8.6-4.2922,15.5705,0,10.8,14.2,10.8,14.2"/>
    <polygon fill="#61b2e4" points="49.297 58.861 49.297 45.986 44.806 45.202 44.806 52.447 26.929 52.447 26.931 45.202 22.265 45.986 22.265 58.861 49.297 58.861"/>
    <polygon fill="#d0cfce" points="67.087 43.423 60.137 59.772 35.147 59.772 42.097 43.423 67.087 43.423"/>
    <polygon fill="#9b9b9a" points="67.303 43.423 60.353 59.772 60.133 59.772 51.363 59.772 58.313 43.423 67.083 43.423 67.303 43.423"/>
    <path fill="#f4aa41" d="m49.1631,33.7883c-2.1131,5.2847-7.4192,8.7024-13.6311,8.7024-5.3551,0-11.31-3.3075-13.4233-8.5922l-.0742-.1813c-.67-1.6576-.5622-3.6865-.5622-5.5835l2.1538-18.7637,6.0076,5.8429c1.7682-.7441,3.6676-1.1263,5.586-1.1239h.6246c1.9184-.0024,3.8178.3798,5.586,1.1239l6.5951-6.4229,2.1863,19.6364c.0024,1.8389-.3508,3.6609-1.04,5.3657"/>
    <path fill="#e27022" d="m35.532,42.4907c6.2312.1985,11.9553-3.3981,14.0684-8.6828l.0651-.1339c.67-1.6576.5626-3.9976.5626-5.8946l-2.2027-18.9894"/>
    <polygon fill="#b399c8" points="22.652 17.7 22.165 22.428 49.297 20.787 49.014 18.333 22.652 17.7"/>
    <path fill="#b399c8" d="m50.8972,19.6c0,1.1046-.8954,2-2,2s-2-.8954-2-2,.8954-2,2-2c1.1044.0004,1.9996.8956,2,2"/>
    <path fill="#fff" d="m47.0723,24.9748s-8.1678,3.4075-7.7837,3.84c7.8154,7.0159,8.4286-2.8627,7.7837-3.84Z"/>
    <path fill="#fff" d="m24.6281,24.9748s7.5569,4.01,7.7837,3.84c-7.5445,7.3839-8.5455-2.2369-7.7837-3.84Z"/>
    <path fill="#fff" d="m53.7216,51.7376c-.514,1.1362-1.6057,1.9026-2.8489,2-1.1035,0-1.62-.8955-1.1511-2,.5142-1.1361,1.6058-1.9024,2.849-2,1.1035,0,1.6194.8965,1.151,2"/>
  </g>
  <g id="line">
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m36.8723,47.8986c-.3528.0548-.7094.0819-1.0665.0811h.125c-3.0736.0063-5.8081-1.4642-9-3.5921-12,0-9.8856,13.561-9.8856,13.561"/>
    <polyline fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" points="35.467 52.133 26.929 52.133 26.931 44.888"/>
    <line x1="22.2649" x2="22.2649" y1="45.7569" y2="57.8666" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
    <polygon fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" points="35.147 59.772 60.137 59.772 67.087 43.423 42.097 43.423 35.147 59.772"/>
    <line x1="24.1767" x2="35.1467" y1="59.7725" y2="59.7725" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
    <line x1="38.2936" x2="35.8502" y1="35.589" y2="32.5747" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"/>
    <line x1="33.4068" x2="35.8502" y1="35.589" y2="32.5747" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"/>
    <line x1="33.4068" x2="38.2936" y1="32.5747" y2="32.5747" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m49.7667,23.869l.4387,4.1844c.0021,1.7794-.3434,3.5421-1.0171,5.189"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m22.5121,33.2423c-.6737-1.6469-1.0192-3.4095-1.0171-5.1889l2.138-18.99,6.4492,6.2109c1.7311-.72,3.5878-1.0893,5.4626-1.0868h.6108c1.875-.0024,3.7319.367,5.4632,1.0868l6.4485-6.2109.6655,6.399"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.8" d="m28.1119,39.9719c2.2346,1.3761,4.8085,2.1022,7.4329,2.0969h.6108c2.6244.0054,5.1983-.7207,7.4329-2.0969"/>
    <ellipse cx="28.5199" cy="27.752" rx="1.2217" ry="1.2057"/>
    <ellipse cx="43.1805" cy="27.752" rx="1.2217" ry="1.2057"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6" d="m47.0723,24.9474s-8.1678,3.4075-7.7837,3.84c7.8154,7.0159,8.4286-2.8627,7.7837-3.84Z"/>
    <line x1="50.9216" x2="45.4239" y1="37.1947" y2="34.1804" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"/>
    <line x1="48.6782" x2="43.1805" y1="39.8089" y2="36.7947" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6" d="m24.6281,24.9474s7.5569,4.01,7.7837,3.84c-7.5445,7.3838-8.5455-2.2369-7.7837-3.84Z"/>
    <line x1="20.7788" x2="26.2765" y1="37.1947" y2="34.1804" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"/>
    <line x1="23.0222" x2="28.5199" y1="39.8089" y2="36.7947" fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6"/>
    <polyline fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6" points="46.998 18.284 22.652 17.7 22.165 22.428 47.005 20.926"/>
    <path fill="none" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.6" d="m50.4972,19.6c0,1.1046-.8954,2-2,2s-2-.8954-2-2,.8954-2,2-2c1.1044.0004,1.9996.8956,2,2"/>
  </g>
</svg>

`;

const spamSVG = `<svg id="emoji" viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <g id="color">
    <path fill="#D0CFCE" d="M28,37l-4,4l-1.3301-0.4409L11.4549,50.89c-0.35-0.6201-0.57-1.44-0.57-2.32V22.06L28,37z"/>
    <path fill="#9B9B9A" d="M60.8249,22.01v26.56c0,0.86-0.2,1.65-0.55,2.27L48.9583,40.478l-1.0289,0.0579l-4.0645-3.806 L60.8249,22.01z"/>
    <line x1="11.5207" x2="11.4583" y1="21.6493" y2="21.6103" fill="none"/>
    <path fill="#D0CFCE" d="M26.8049,36.75l4.47,4.13c0.24,0.22,0.48,0.41,0.72,0.57c2.4301,1.8,5.26,1.8,7.6801-0.01 c0.23-0.16,0.47-0.36,0.69-0.56l4.5-4.15"/>
    <path fill="#D0CFCE" stroke="#D0CFCE" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="1.8" d="M26.8049,36.75l4.47,4.13c0.24,0.22,0.48,0.41,0.72,0.57c2.4301,1.8,5.26,1.8,7.6801-0.01c0.23-0.16,0.47-0.36,0.69-0.56l4.5-4.15 l15.41,14.11c-0.42,0.77-1.07,1.27-1.79,1.27h-45.26c-0.7,0-1.34-0.47-1.77-1.22L26.8049,36.75"/>
    <path fill="#D0CFCE" d="M47.9294,39.536L60.2749,50.84c-0.42,0.77-1.07,1.27-1.79,1.27h-45.26c-0.7,0-1.34-0.47-1.77-1.22 L23.533,39.764"/>
    <path fill="#D0CFCE" d="M60.8249,22.01l-15.96,14.72l-4.5,4.15c-0.22,0.2-0.46,0.4-0.69,0.56c-2.42,1.81-5.25,1.81-7.6801,0.01 c-0.24-0.16-0.48-0.35-0.72-0.57l-4.47-4.13l-15.92-14.69c0.04-0.06,0.09-0.13,0.14-0.2c0.42-0.6,0.99-0.96,1.61-0.96h46.48 c0.59,0,1.16,0.35,1.5699,0.91C60.7349,21.87,60.7849,21.94,60.8249,22.01z"/>
  </g>
  <g id="hair"/>
  <g id="skin"/>
  <g id="skin-shadow"/>
  <g id="line">
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" d="M22.6699,40.5591L11.4549,50.89c-0.35-0.6201-0.57-1.44-0.57-2.32V22.06"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" d="M60.8249,22.01v26.56c0,0.86-0.2,1.65-0.55,2.27L48.9583,40.478"/>
    <line x1="11.5207" x2="11.4583" y1="21.6493" y2="21.6103" fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" d="M26.8049,36.75l4.47,4.13c0.24,0.22,0.48,0.41,0.72,0.57c2.4301,1.8,5.26,1.8,7.6801-0.01c0.23-0.16,0.47-0.36,0.69-0.56l4.5-4.15"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" d="M47.9294,39.536L60.2749,50.84c-0.42,0.77-1.07,1.27-1.79,1.27h-45.26c-0.7,0-1.34-0.47-1.77-1.22L23.533,39.764"/>
    <path fill="none" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" stroke-width="2" d="M60.8249,22.01l-15.96,14.72l-4.5,4.15c-0.22,0.2-0.46,0.4-0.69,0.56c-2.42,1.81-5.25,1.81-7.6801,0.01 c-0.24-0.16-0.48-0.35-0.72-0.57l-4.47-4.13l-15.92-14.69c0.04-0.06,0.09-0.13,0.14-0.2c0.42-0.6,0.99-0.96,1.61-0.96h46.48 c0.59,0,1.16,0.35,1.5699,0.91C60.7349,21.87,60.7849,21.94,60.8249,22.01z"/>
  </g>
</svg>
`;

/* Create Image objects (preload) */
const botImg          = new Image();
botImg.src            = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(botSVG);

const hackerImg       = new Image();
hackerImg.src         = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(hackerSVG);

const idThiefImg      = new Image();
idThiefImg.src        = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(idThiefSVG);

const catImg           = new Image();
catImg.src            = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(catSVG);

const spamImg = new Image();
spamImg.src  = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(spamSVG);

/* Map kind -> image for convenience */
const BOT_ASSETS = {
  bot: botImg,
  hacker: hackerImg,
  idThief: idThiefImg,
  neighbourCat: catImg,
  spam: spamImg
};


/* -------------- Utilities -------------- */
function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
function cellToPx(cx, cy){ return { x: cx * GRID + GRID/2, y: cy * GRID + GRID/2 }; }

/* -------------- Init / Reset -------------- */
function resetGame(){
  gameOver = false;
  isRunning = false;
  dir = { x: 0, y: 0 };
  nextDir = null;
  // ... existing reset logic follows
  snake = [];
  const startX = Math.floor(COLS/2);
  const startY = Math.floor(ROWS/2);
  snake = [{ x: startX, y: startY }];
  dir = { x: 1, y: 0 };
  nextDir = null;
  bots = [];
  particles = [];
    // reset counts
  destroyedCounts = { bot:0, hacker:0, idThief:0, spam:0, neighbourCat:0 };
  score = 0;
  scoreEl.textContent = score;
  clearTimers();
  render(); // draw initial frame
}

/* -------------- Bot spawning -------------- */
function spawnBot(){
  if(bots.length >= MAX_BOTS) return;
  let tries = 0;
  while(tries < 120){
    const bx = randInt(1, COLS-2);
    const by = randInt(1, ROWS-2);
    const collidingSnake = snake.some(s => s.x === bx && s.y === by);
    const collidingBot = bots.some(b => b.x === bx && b.y === by);
    if(!collidingSnake && !collidingBot){
      // choose kind with weights (adjust weights array to tune frequency)
      const kinds = [
        { k:'bot', w:40 },
        { k:'hacker', w:9 },
        { k:'idThief', w:10 },
        { k:'neighbourCat', w:1 },
        { k:'spam', w:40 }
      ];
      // weighted pick
      const total = kinds.reduce((s,it)=>s+it.w,0);
      let r = randInt(1, total);
      let chosen = kinds[0].k;
      for(const it of kinds){
        if(r <= it.w){ chosen = it.k; break; }
        r -= it.w;
      }

      const img = BOT_ASSETS[chosen] || botImg;
      // minor behavior flags â€” cats are cute and may move a bit; spam can wander more
      const movement = (chosen === 'neighbourCat') ? 'skitter' : (chosen === 'spam' ? 'patrol' : (chosen === 'hacker' ? 'drift' : 'static'));

      bots.push({ x: bx, y: by, kind: chosen, img: img, spawnedAt: Date.now(), movement });
      break;
    }
    tries++;
  }
}


/* -------------- Particles (for explosion effect) -------------- */
function explosionColorForKind(kind){
  switch(kind){
    case 'hacker': return '#4DFED1';
    case 'idThief': return '#4DFED1';
    case 'neighbourCat': return '#FFBF00';
    case 'spam': return '#D0CFCE';
    default: return '#D0CFCE';
  }
}


function createExplosion(cx, cy, color=explosionColorForKind, count=18){
  const center = cellToPx(cx, cy);
  for(let i=0;i<count;i++){
    const angle = (Math.PI * 2) * Math.random();
    const speed = 1 + Math.random()*3;
    particles.push({
      x: center.x,
      y: center.y,
      vx: Math.cos(angle)*speed,
      vy: Math.sin(angle)*speed - 1.2, // little upward bias
      life: 60 + Math.floor(Math.random()*20),
      age: 0,
      color: color,
      size: 2 + Math.random()*3
    });
  }
}

/* -------------- Game step (movement + collision) -------------- */
function step(){
  // advance direction if queued
  if(nextDir){
    // prevent reversing
    if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)){
      dir = nextDir;
    }
    nextDir = null;
  }
  // compute new head
  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  // wall collision -> game over (simple reset)
  if(head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
    // reset + flash effect
    flashGameOver();
    return;
  }

  // self collision -> game over
  if(snake.some((seg, idx)=> idx>0 && seg.x===head.x && seg.y===head.y)){
    flashGameOver();
    return;
  }

  // insert new head
  snake.unshift(head);

  // check bot collision
  const botIndex = bots.findIndex(b => b.x === head.x && b.y === head.y);
  if(botIndex !== -1){
  // destroy bot and score
  const b = bots.splice(botIndex,1)[0];

// explosion color based on kind
const color = explosionColorForKind(b.kind || 'bot');
createExplosion(head.x, head.y, color, 20);

// award points based on kind (fallback to 1)
const pts = POINTS_BY_KIND[b.kind] ?? 1;
destroyedCounts[b.kind] = (destroyedCounts[b.kind] || 0) + 1;
score += pts;
scoreEl.textContent = score;

  // tiny floating +pts text particle
  const center = cellToPx(head.x, head.y);
  particles.push({
    isText: true,
    text: `+${pts}`,
    x: center.x,
    y: center.y - GRID*0.15, // slightly above the mascot center
    vx: (Math.random()-0.5) * 0.6,
    vy: -1.6 - Math.random()*0.6, // float upward
    life: 48,
    age: 0,
    color: '#ffffff',
    size: 24
  });


  if(score > highScore){
    highScore = score;
    localStorage.setItem('billions_high', highScore);
    highEl.textContent = highScore;
  }
}

// ALWAYS keep only the head
snake = [snake[0]];

}

/* tiny visual game over flash then reset */
function flashGameOver(){
  // stop running and timers
  isRunning = false;
  clearTimers();
  gameOver = true;

  // quick red flash effect (brief)
  ctx.save();
  ctx.fillStyle = 'rgba(255,0,0,0.12)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.restore();

  // render one final frame with overlay
  render();
}


/* -------------- Render -------------- */
function render(){
  // background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // subtle grid background
  ctx.fillStyle = '#04121b';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw bots (food)
  for(const b of bots){
    drawBot(b.x, b.y, b.kind);
  }

  // draw mascot as head â€” using the mascot image and keeping it constant size
  if(snake.length > 0){
    const head = snake[0];
    const p = cellToPx(head.x, head.y);
    const size = GRID; // head sprite size (keeps same even when snake grows)
    // draw a circular backdrop so mascot pops
    ctx.save();
    ctx.beginPath();
    ctx.arc(p.x, p.y, size/1.8, 0, Math.PI*2);
    ctx.fillStyle = '#001826';
    ctx.shadowColor = 'rgba(0,70,255,0.18)';
    ctx.shadowBlur = 8;
    ctx.fill();
    ctx.shadowBlur = 0;
    // draw mascot image centered
    ctx.drawImage(mascotImg, p.x - size/2, p.y - size/2, size, size);
    ctx.restore();
  }

  // particles
    // particles (including floating text)
  for(let i=particles.length-1;i>=0;i--){
    const pt = particles[i];
    const alpha = 1 - pt.age/pt.life;
    ctx.globalAlpha = alpha;

    if(pt.isText){
      // draw floating text (centered)
      ctx.fillStyle = pt.color || '#fff';
      ctx.font = `700 ${pt.size || 14}px Inter, Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      // slight shadow for legibility
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.45)';
      ctx.shadowBlur = 6;
      ctx.fillText(pt.text, pt.x, pt.y);
      ctx.restore();
    } else {
      // circle particle (existing behavior)
      ctx.fillStyle = pt.color || '#fff';
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, pt.size || 2, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;
  }


    // --- Responsive Game Over overlay (replace old fixed-size block) ---
  if(gameOver){
    ctx.save();

    // dim background
    ctx.fillStyle = 'rgba(2,6,12,0.75)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // compute overlay size relative to canvas
    const pad = Math.round(canvas.width * 0.05); // page padding
    const maxW = canvas.width - pad*2;
    const maxH = canvas.height - pad*2;
    // overlay uses up to 86% width and 70% height, whichever fits
    const w = Math.min(Math.round(maxW * 0.86), 520);
    const h = Math.min(Math.round(maxH * 0.75), 360);
    // center
    const cx = Math.round((canvas.width - w) / 2);
    const cy = Math.round((canvas.height - h) / 2);

    // scale factor for fonts and spacing (1 at 640px)
    const scale = canvas.width / 640;

    // card backdrop
    ctx.fillStyle = 'rgba(0,0,0,0.52)';
    roundRect(ctx, cx, cy, w, h, Math.max(8, Math.round(12 * scale)), true, true);

    // Title
    ctx.fillStyle = '#FFD700';
    ctx.textAlign = 'center';
    ctx.font = `bold ${Math.max(28, Math.round(24*scale))}px Inter, Arial, sans-serif`;
    ctx.fillText('GAME OVER', canvas.width/2, cy + Math.round(36 * scale));

    // Final Total Score
    ctx.fillStyle = '#ffffff';
    ctx.font = `700 ${Math.max(36, Math.round(32*scale))}px Inter, Arial, sans-serif`;
    ctx.fillText(`${score} pts`, canvas.width/2, cy + Math.round(36 * scale) + Math.round(44 * scale));

    // Breakdown header
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.font = `600 ${Math.max(22, Math.round(12*scale))}px Inter, Arial, sans-serif`;
    ctx.textAlign = 'left';

    // layout columns that adapt to width
    const leftX = cx + Math.round(20 * scale);
    const rightX = cx + w - Math.round(20 * scale);
    let y = cy + Math.round(36 * scale) + Math.round(92 * scale);

    // small header line
    ctx.fillText('Enemies', leftX, y);
    ctx.fillText('Kills', rightX*0.9, y);
    y += Math.round(30 * scale);

    // ORDER & LABELS
    const ORDER = ['bot','spam','idThief','hacker','neighbourCat'];
    const LABELS = {
      bot: 'Spam Bot',
      spam: 'Spam Burst',
      idThief: 'ID Thief',
      hacker: 'Hacker',
      neighbourCat: 'Legendary Cat'
    };
    const COLOURS = {
      bot: '#D0CFCEcc',
      spam: '#D0CFCEcc',
      idThief: '#4DFED1cc',
      hacker: '#4DFED1cc',
      neighbourCat: '#FFBF00cc'
    };

    // compute line height and max lines that fit
    const lineH = Math.round(18 * scale);
    const availableH = cy + h - Math.round(78 * scale) - y; // space for prompt
    const maxLines = Math.max(1, Math.floor(availableH / lineH));

    // If not enough vertical space, compress and use two-column compact layout
    if(maxLines < ORDER.length){
      // compact two-column layout
      const half = Math.ceil(ORDER.length/2);
      const col1 = ORDER.slice(0, half);
      const col2 = ORDER.slice(half);

      const colLeftX = leftX;
      const colRightX = cx + Math.round(w/2) + Math.round(8 * scale);
      let y1 = y;
      for(const k of col1){
        const cnt = destroyedCounts[k] || 0;
        const per = POINTS_BY_KIND[k] ?? 1;
        const subtotal = cnt * per;
        // ctx.fillStyle = 'rgba(255,255,255,0.86)';
        ctx.font = `600 ${Math.max(16, Math.round(11*scale))}px Inter, Arial, sans-serif`;
        ctx.textAlign = 'left';
        ctx.fillStyle = COLOURS[k];
        ctx.fillText(`${LABELS[k]}`, colLeftX, y1);
        ctx.textAlign = 'right';
        ctx.fillText(`${cnt}`, colRightX + Math.round(w/2) - Math.round(36*scale), y1);
        y1 += lineH*1.5;
      }
      let y2 = y;
      for(const k of col2){
        const cnt = destroyedCounts[k] || 0;
        const per = POINTS_BY_KIND[k] ?? 1;
        const subtotal = cnt * per;
        ctx.textAlign = 'left';
        ctx.fillStyle = COLOURS[k];
        ctx.fillText(`${LABELS[k]}`, colRightX, y2);
        ctx.textAlign = 'right';
        ctx.fillText(`${cnt}`, cx + w - Math.round(36*scale), y2);
        y2 += lineH*1.5;
      }
    } else {
      // normal single-column listing
      for(const k of ORDER){
        const cnt = destroyedCounts[k] || 0;
        const per = POINTS_BY_KIND[k] ?? 1;
        const subtotal = cnt * per;
        ctx.fillStyle = 'rgba(255,255,255,0.86)';
        ctx.font = `600 ${Math.max(16, Math.round(12*scale))}px Inter, Arial, sans-serif`;
        ctx.textAlign = 'left';
        ctx.fillStyle = COLOURS[k];
        ctx.fillText(`${LABELS[k]}`, leftX, y);
        ctx.textAlign = 'right';
        ctx.fillText(`${cnt}`, rightX*0.95, y);
        ctx.textAlign = 'left';
        y += lineH*1.5;
      }
    }

    // Prompt (now includes "CLICK HERE" text)
const prompt = 'Click here to Restart';
ctx.font = `600 ${Math.max(22, Math.round(12*scale))}px Inter, Arial, sans-serif`;
ctx.fillStyle = '#00BFFFcc';
ctx.textAlign = 'center';
const promptY = cy + h - Math.round(20 * scale);
drawWrappedText(ctx, prompt, canvas.width/2, promptY, Math.round(w - 48*scale), Math.round(16*scale));

// store clickable hotspot for later
CLICK_AREA = {
  x: canvas.width/2 - (w * 0.45),
  y: promptY - Math.round(16*scale),
  width: w * 0.90,
  height: Math.round(32*scale)
};


    ctx.restore();
  }

  // helper: draw wrapped text (centered by x)
  function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight){
    const words = text.split(' ');
    let line = '';
    let cursorY = y - lineHeight; // will add lineHeight on first flush to position baseline nicely
    for(let n = 0; n < words.length; n++){
      const test = line + (line ? ' ' : '') + words[n];
      const metrics = ctx.measureText(test);
      if(metrics.width > maxWidth && line !== ''){
        cursorY += lineHeight;
        ctx.fillText(line, x, cursorY);
        line = words[n];
      } else {
        line = test;
      }
    }
    // last line
    if(line !== ''){
      cursorY += lineHeight;
      ctx.fillText(line, x, cursorY);
    }
  }

  // helper: rounded rect
  function roundRect(ctx, x, y, w, h, r, fill, stroke){
    if(typeof r === 'undefined') r = 6;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke){ ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.stroke(); }
  }



}

/* draw a bot icon (simple graphic) */
function drawBot(cx, cy, kind){
  const p = cellToPx(cx, cy);
  const size = GRID * 1.2;
  const img = BOT_ASSETS[kind] || botImg;
  // draw a small pale background circle for pop
  ctx.save();
  ctx.beginPath();
  ctx.arc(p.x, p.y, size*0.55, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fill();
  // draw image centered
  ctx.drawImage(img, p.x - size/2, p.y - size/2, size, size);

  // draw small kind badge top-left of the bot
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(p.x - size/2, p.y - size/2 - 6, 36, 14);
  ctx.fillStyle = '#fff';
  ctx.font = '10px monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'middle';
  const label = kind === 'idThief' ? 'ID Thief' : (kind === 'neighbourCat' ? 'Real Cat' : (kind === 'spam' ? 'Spams' : (kind === 'hacker' ? 'Hacker' : 'AI Bot')));
  ctx.fillText(label, p.x - size/2 + 4, p.y - size/2 + 1);
  ctx.restore();
}



/* -------------- Update (particles movement) -------------- */
function update(){
  // update particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.08; // gravity
    p.age++;
    if(p.age >= p.life) particles.splice(i,1);
  }
  render();
}

/* -------------- Timers control -------------- */
function clearTimers(){
  if(stepTimer) { clearInterval(stepTimer); stepTimer = null; }
  if(spawnTimer) { clearInterval(spawnTimer); spawnTimer = null; }
  if(gameInterval) { cancelAnimationFrame(gameInterval); gameInterval = null; }
}

function startGame(){
  if(isRunning) return;
  isRunning = true;
  // step every (1000/FPS) ms
  const stepMs = Math.round(1000 / FPS);
  stepTimer = setInterval(()=> { step(); }, stepMs);
  spawnTimer = setInterval(()=> { spawnBot(); }, BOT_SPAWN_INTERVAL);
  // animation frame for smooth particles + drawing
  function loop(){ update(); gameInterval = requestAnimationFrame(loop); }
  loop();
}

/* -------------- Input -------------- */
window.addEventListener('keydown', (e)=>{
  const k = e.key;

    // Space: if on Game Over -> restart; otherwise toggle start/pause
  if(k === ' '){
    if(gameOver){
      // quick restart: reset but also immediately start
      resetGame();
    }
    return;
  }

  if(gameOver) return;

  // Map keys to direction
  let wanted = null;
  if(k === 'ArrowLeft' || k === 'a') wanted = {x:-1,y:0};
  if(k === 'ArrowRight' || k === 'd') wanted = {x:1,y:0};
  if(k === 'ArrowUp' || k === 'w') wanted = {x:0,y:-1};
  if(k === 'ArrowDown' || k === 's') wanted = {x:0,y:1};

  if(!wanted) return; // not a control key

  // If game isn't running yet, start it on first direction press
   if(!isRunning){
    dir = wanted;
    nextDir = null;
    startGame();
    return;
  }

  // Queue direction change (nextDir) but prevent immediate reversal
  // If the player presses the opposite of current dir, ignore it
  if(!(wanted.x === -dir.x && wanted.y === -dir.y)){
    nextDir = wanted;
  }
});

/* mobile arrows â€” robust pointer/touch/click handlers */
['upBtn','leftBtn','downBtn','rightBtn'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;

  const mapping = {
    upBtn:    {x:0,  y:-1},
    downBtn:  {x:0,  y:1},
    leftBtn:  {x:-1, y:0},
    rightBtn: {x:1,  y:0}
  };
  const wantedFor = mapping[id];

  const handlePress = (ev)=>{
    if(ev && ev.preventDefault) ev.preventDefault();
    if(gameOver) return;

    const wanted = wantedFor;
    if(!isRunning){
      // first press sets direction and starts game (same as keyboard)
      dir = wanted;
      nextDir = null;
      startGame();
      return;
    }
    // queue change but block immediate 180Â° reversal
    if(!(wanted.x === -dir.x && wanted.y === -dir.y)){
      nextDir = wanted;
    }
  };

  // pointer events first â€” unify mouse/touch/stylus
  el.addEventListener('pointerdown', handlePress);
  // keep touchstart with passive:false to ensure preventDefault works on some mobiles
  el.addEventListener('touchstart', handlePress, { passive: false });
  // click/mouse fallback
  el.addEventListener('mousedown', handlePress);
  el.addEventListener('click', handlePress);
  canvas.addEventListener('click', (e)=>{
  if(!gameOver || !CLICK_AREA) return;

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  // Check if click falls inside the clickable area
  if(
    mx >= CLICK_AREA.x &&
    mx <= CLICK_AREA.x + CLICK_AREA.width &&
    my >= CLICK_AREA.y &&
    my <= CLICK_AREA.y + CLICK_AREA.height
  ){
    resetGame();
    return;
  }
});

canvas.addEventListener('mousemove', (e)=>{
  if(!gameOver || !CLICK_AREA){
    canvas.style.cursor = 'default';
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  if(
    mx >= CLICK_AREA.x &&
    mx <= CLICK_AREA.x + CLICK_AREA.width &&
    my >= CLICK_AREA.y &&
    my <= CLICK_AREA.y + CLICK_AREA.height
  ){
    canvas.style.cursor = 'pointer';   // ðŸ‘ˆ hand cursor!
  } else {
    canvas.style.cursor = 'default';
  }
});



  // small a11y: also react to keyboard Enter/Space when focused
  el.tabIndex = 0;
  el.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); handlePress(e); } });
});


/* pause */
function pauseGame(){
  isRunning = false;
  clearTimers();
}

/* -------------- Main loop start -------------- */
resetGame();
// spawn a few bots to begin
for(let i=0;i<3;i++) spawnBot();

/* ensure mascot image is ready before first render */
mascotImg.onload = ()=> { render(); };

/* Keep a smooth update even if not running (particles still update when running) */
(function mainTicker(){
  update();
  requestAnimationFrame(mainTicker);
})();
</script>
</body>
</html>
